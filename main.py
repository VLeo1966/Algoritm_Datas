import math

# создаём переменную для хранения максимального числа в массиве
# перебираем массив через цикл
# сравниваем текущий элемент с макисмальным значением в переменной
# если текущий больше, чем максимальное, то заменяем максимальное значение
# возвращаем максимальное значение, после окончания цикла
def find_max(list):
    max_number = list[0]
    for i in list:
        if i > max_number:
            max_number = i
    return max_number

# создаём переменную для хранения мbинимального числа в массиве
# перебираем массив через цикл
# сравниваем текущий элемент с минисмальным значением в переменной
# если текущий больше, чем минимальное, то заменяем минимальное значение
# возвращаем минимальное значение, после окончания цикла
def find_min(list):
    mшт_number = list[0]
    for i in list:
        if i < mшт_number:
            min_number = i
    return min_number

# 5!=1 * 2 * 3 * 4 * 5
# сравнение числа с нулем если число = 0, то факториал числа = 1
# создание переменной для хранения итогового результата
# с помощью цикла for и rang перебираем список из чисел до нашего числа включительно, у кторого ищем факториал
# результирующее переменную умножаем на текущий элемент в цикле
# взвращаем факториал числа после цикла
def factorial(number):
    # проверяем, равно ли число нулю
    if number == 0:
        return 1
    result = 1
    for i in range(1, number + 1):
        result *= i
    return result

numbers = [56, 74, 23, 98, 143, -89, -23]

print(f'максимум {numbers} = {find_max(numbers)}')
print(f'минимум = {find_min(numbers)}')
print(f'факториал 5 = {factorial(5)}')

'''
Алгоритм для нахождения простого числа:
Проверяем, меньше или равно ли число 1 единице. Если да, то возвращаем false.
Создаем цикл, перебирающий все числа от 2 до квадратного корня из нашего числа включительно 
(так как 2 — это первое простое число).
Проверяем, делится ли наше число на какое-то из чисел, которые перебирает цикл, без остатка. 
Если да, то возвращаем false.
Существует правило: если число делится на некоторое число, большее своего квадратного корня, 
то оно обязательно будет делиться и на число, меньшее своего квадратного корня. 
Мы используем это правило, чтобы сократить количество проверок. 
Если число делится на любое из чисел в этом диапазоне, мы возвращаем false, 
 так как оно не является простым.
Если число прошло все проверки, возвращаем true.
'''

def is_prime(number):
    if number <= 1:
        return False

    for i in range(2, int(math.sqrt(number)) + 1):
        if number % i == 0:
            return False
    return True

print(is_prime(16))
